package com.coremedia.blueprint.common.util;

import com.coremedia.blueprint.base.settings.SettingsService;
import com.coremedia.blueprint.base.tree.TreeRelation;
import com.coremedia.blueprint.base.util.StructUtil;
import com.coremedia.blueprint.cae.search.Condition;
import com.coremedia.blueprint.cae.search.SearchConstants;
import com.coremedia.blueprint.cae.search.SearchQueryBean;
import com.coremedia.blueprint.cae.search.Value;
import com.coremedia.blueprint.cae.search.solr.SolrQueryBuilder;
import com.coremedia.blueprint.cae.search.solr.SolrSearchFormatHelper;
import com.coremedia.blueprint.common.contentbeans.CMContext;
import com.coremedia.blueprint.common.contentbeans.CMLocTaxonomy;
import com.coremedia.blueprint.common.contentbeans.CMNavigation;
import com.coremedia.blueprint.common.contentbeans.CMQueryList;
import com.coremedia.blueprint.common.contentbeans.CMTaxonomy;
import com.coremedia.blueprint.common.services.context.CurrentContextService;
import com.coremedia.cap.common.IdHelper;
import com.coremedia.cap.content.Content;
import com.coremedia.cap.content.ContentRepository;
import com.coremedia.cap.struct.Struct;
import com.coremedia.objectserver.beans.ContentBean;
import com.coremedia.objectserver.beans.ContentBeanFactory;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DateUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;

/**
 * Uses the local settings struct generated by teh Studio
 * query editor and converts it to a SearchQuery object that
 * is used e.g. for CMQueryList content.
 */
public class SettingsStructToSearchQueryConverter {
  private static final Logger LOG = LoggerFactory.getLogger(SettingsStructToSearchQueryConverter.class);

  //See RequestAttributeConstants
  private static final String REQUEST_ATTR_NAME_PAGE_MODEL = "cmpage_model";

  private static final String KEY_SUBJECT_TAXONOMY = SearchConstants.FIELDS.SUBJECT_TAXONOMY.toString();
  private static final String KEY_LOCATION_TAXONOMY = SearchConstants.FIELDS.LOCATION_TAXONOMY.toString();
  private static final String KEY_MODIFICATION_DATE = SearchConstants.FIELDS.MODIFICATION_DATE.toString();
  private static final String KEY_DOCUMENT_TYPE = SearchConstants.FIELDS.DOCUMENTTYPE.toString();

  public static final String KEY_CONTEXT_TAXONOMIES = "contextTaxonomies";

  private static final String KEY_DOCUMENTS = "documents";
  private static final String KEY_LIMIT = "limit";
  private static final String KEY_ORDER = "order";

  private static final String KEY_FQ = "fq";
  private final ContentRepository contentRepository;

  private SearchQueryBean searchQuery;
  private CMQueryList queryList;
  private CurrentContextService currentContextService;
  private TreeRelation<Content> treeRelation;
  private SettingsService settingsService;
  private ContentBeanFactory contentBeanFactory;

  public SettingsStructToSearchQueryConverter(CMQueryList queryList,
                                              CurrentContextService currentContextService,
                                              TreeRelation<Content> treeRelation,
                                              SettingsService settingsService,
                                              ContentBeanFactory contentBeanFactory) {
    this.queryList = queryList;
    this.currentContextService = currentContextService;
    this.treeRelation = treeRelation;
    this.settingsService = settingsService;
    this.contentBeanFactory = contentBeanFactory;
    contentRepository = queryList.getContent().getRepository();
  }

  /**
   * Reads the solr search settings from the local settings properties.
   * The struct xml has been generated by the dynamic query editor in the Studio.
   *
   * @return The SearchQueryBean.
   */
  public SearchQueryBean convert() {
    searchQuery = new SearchQueryBean();
    searchQuery.setQuery(SolrQueryBuilder.ANY_FIELD_ANY_VALUE);

    //apply context
    CMContext context = currentContextService.getContext();
    if (context != null) {
      Content root = treeRelation.pathToRoot(context.getContent()).get(0);
      searchQuery.setContext(String.valueOf(IdHelper.parseContentId(root.getId())));
    }

    applyLimit();
    applyOrder();

    Struct fqStruct = settingsService.setting(KEY_FQ, Struct.class, queryList.getContent());
    if (fqStruct != null) {
      applyDocumentType(fqStruct);
      applyContexts(fqStruct);
      applyKeywords(fqStruct, KEY_SUBJECT_TAXONOMY, SearchConstants.FIELDS.SUBJECT_TAXONOMY);
      applyKeywords(fqStruct, KEY_LOCATION_TAXONOMY, SearchConstants.FIELDS.LOCATION_TAXONOMY);
      applyContextKeywords(fqStruct, KEY_CONTEXT_TAXONOMIES);
      applyModificationDate(fqStruct);
    }

    return searchQuery;
  }

  /**
   * Applies the order by param to the query if set.
   */
  private void applyOrder() {
    String orderBy = settingsService.setting(KEY_ORDER, String.class, queryList.getContent());
    if (orderBy!=null && orderBy.contains(" ")) {
      String field = orderBy.split(" ")[0];
      for (int i = 0; i < SearchConstants.FIELDS.values().length; i++) {
        if (SearchConstants.FIELDS.values()[i].toString().equalsIgnoreCase(field)) {
          List<String> sortFields = new ArrayList<>();
          sortFields.add(orderBy);
          searchQuery.setSortFields(sortFields);
        }
      }
    }
  }

  /**
   * Applies the number of items.
   */
  private void applyLimit() {
    Integer limit = settingsService.setting(KEY_LIMIT, Integer.class, queryList.getContent());
    if (limit!=null && limit>0) {
      searchQuery.setLimit(limit);
    }
  }

  /**
   * Applies the publication date to the query.
   * Be aware that the publication date can be entered without formatting
   * using the expert mode of the Studio!
   */
  private void applyModificationDate(Struct fqStruct) {
    String dateString = StructUtil.getString(fqStruct, KEY_MODIFICATION_DATE);
    if (!StringUtils.isEmpty(dateString)) {
      if (dateString.contains(":")) {
        dateString = dateString.split(":")[1];
      }

      if (dateString.length() > 0) {
        Calendar calculatedDate = calcDate(dateString);
        String formattedString = SolrSearchFormatHelper.calendarToString(calculatedDate);
        searchQuery.addFilter(Condition.greaterThan(SearchConstants.FIELDS.MODIFICATION_DATE, Value.exactly(formattedString)));
      }
    }
  }

  /**
   * Takes the documents from the query (channel documents)
   * add them as navigation criteria to the query.
   */
  private void applyContexts(Struct fqStruct) {
    List<Content> docs = StructUtil.getLinks(fqStruct, KEY_DOCUMENTS);
    if (!docs.isEmpty()) {
      List<CMNavigation> navigations = contentBeanFactory.createBeansFor(docs, CMNavigation.class);
      List<String> convertedNavigation = ContentBeanSolrSearchFormatHelper.cmNavigationsToId(navigations);
      searchQuery.addFilter(Condition.is(
              SearchConstants.FIELDS.NAVIGATION_PATHS, Value.anyOf(convertedNavigation)));
    }
  }


  /**
   * Parses the documents types, retrieves the concrete instances from
   * the repository and adds them to the query list.
   */
  private void applyDocumentType(Struct fqStruct) {
    String docTypes = StructUtil.getString(fqStruct, KEY_DOCUMENT_TYPE);
    if (!StringUtils.isEmpty(docTypes)) {
      final Condition documentTypeFilter = SearchQueryUtil.createDocumentTypeFilter(docTypes, contentRepository);
      searchQuery.addFilter(documentTypeFilter);
    }
  }

  /**
   * Parsing keywords and applying them to the query.
   *
   * @param fqId  the struct field used to load the selected keywords
   * @param field the solr field used to store the information
   */
  private void applyKeywords(Struct fqStruct, String fqId, SearchConstants.FIELDS field) {
    List<Content> docs = StructUtil.getLinks(fqStruct, fqId);
    if (!docs.isEmpty()) {
      List<CMTaxonomy> taxonomies = contentBeanFactory.createBeansFor(docs, CMTaxonomy.class);
      List<String> taxonomyIds = ContentBeanSolrSearchFormatHelper.cmObjectsToIds(taxonomies);
      searchQuery.addFilter(Condition.is(field, Value.anyOf(taxonomyIds)));
    }
  }


  /**
   * Parsing related keywords and applying them to the query.
   *
   * @param fqId  the struct field used to load the selected keywords
   */
  private void applyContextKeywords(Struct fqStruct, String fqId) {
    boolean useContextTaxonomies = StructUtil.getBoolean(fqStruct, fqId);
    if (useContextTaxonomies) {
      RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
      if (requestAttributes instanceof ServletRequestAttributes) {
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
        ContentBean taxonomy = (ContentBean) request.getAttribute(REQUEST_ATTR_NAME_PAGE_MODEL);
        if (taxonomy == null && request.getSession(false) != null) { //maybe the preview handler has stored the value in the session.
          String taxonomyCapId = (String) request.getSession(false).getAttribute(REQUEST_ATTR_NAME_PAGE_MODEL);
          if (taxonomyCapId != null) {
            Content taxonomyContent = contentRepository.getContent(taxonomyCapId);
            taxonomy = queryList.getContentBeanFactory().createBeanFor(taxonomyContent);
          }
        }
        if (taxonomy != null && taxonomy.getContent().getType().isSubtypeOf(CMTaxonomy.NAME)) {
          LOG.debug("Found taxonomy {} in the request: gonna use this for the CMQueryList as context", taxonomy.getContent().getName());
          String id = String.valueOf(IdHelper.parseContentId(taxonomy.getContent().getId()));
          if (taxonomy.getContent().getType().isSubtypeOf(CMLocTaxonomy.NAME)) {
            searchQuery.addFilter(Condition.is(SearchConstants.FIELDS.LOCATION_TAXONOMY, Value.anyOf(Arrays.asList(id))));
          }
          else if (taxonomy.getContent().getType().isSubtypeOf(CMTaxonomy.NAME)) {
            searchQuery.addFilter(Condition.is(SearchConstants.FIELDS.SUBJECT_TAXONOMY, Value.anyOf(Arrays.asList(id))));
          }
        }
      }
    }
  }

  /**
   * Checks the settings done by the modification date query editor.
   * Creates and manipulates a date for it.
   *
   * @param dateString The raw format serialized in the struct.
   * @return The date that should be used as (mod) date for the query.
   */
  private Calendar calcDate(String dateString) {
    Calendar cal = new GregorianCalendar();
    String replacedDateString = dateString.replaceAll("\\[", "").replaceAll("\\]", "");
    if (replacedDateString.contains("TODAY")) {
      //because today started at midnight!
      cal.set(Calendar.HOUR_OF_DAY, 0);
      cal.set(Calendar.MINUTE, 0);
      cal.set(Calendar.SECOND, 0);
      cal.set(Calendar.MILLISECOND, 0);
    } else
    if (replacedDateString.contains("DAYS TO NOW")) {
      int days = Integer.parseInt(replacedDateString.split(" ")[0]);
      Date formattedDate = DateUtils.addDays(cal.getTime(), -days);
      cal.setTime(formattedDate);
    }
    return cal;
  }
}
